# P99 (99th Percentile)

### 1. 核心定義
**P99 (第 99 百分位數)** 是一個統計指標，用來描述系統的**最差表現 (Worst-case performance)**。
> 在所有的請求中，**99%** 的請求回應時間都 **快於或等於 500ms**，只有 **最慢的 1%** 超過這個時間。

**公式概念：** 將所有數據由小到大排序，取第 99% 位置的數值。

### 2. 為什麼不用平均值 (Average)？
**平均值的陷阱：** 假設有 100 個請求：
* 99 個請求耗時 **1ms**
* 1 個請求耗時 **10,000ms (10秒)** —— 可能是因為 GC 停頓或網路抖動。
* **平均值 (Avg)：** 約 100ms (看起來還不錯)。
* **P99：** 10,000ms (揭露了嚴重的卡頓問題)。

對於高頻交易或即時系統，那 1% 的極端延遲往往才是導致用戶流失或套利失敗的主因，平均值無法反映這種**長尾效應 (Long Tail)**。

### 3. P99 在分散式系統的重要性
在微服務 (Microservices) 架構下，P99 的影響會被**放大**。

* **木桶效應 (Tail at Scale)：**
    如果一個用戶的動作需要呼叫後端 100 個微服務，只要其中**任何一個**服務剛好碰上它的 P99 延遲，整個用戶請求就會變慢。
* **SLA (服務水準協議)：**
    高品質的服務合約通常基於 P99 或 P99.9 (3個9) 來簽訂，例如：「保證 P99 延遲在 200ms 以內」，這比保證平均值更具挑戰性。

### 4. 如何測量
由於需要排序大量數據，計算精確的 P99 在大數據量下極為消耗記憶體。實務上通常採用 **HdrHistogram** 或 **T-Digest** 等演算法，透過犧牲極微小的精度（使用 Bucket 統計）來換取極低的記憶體消耗與 O(1) 的寫入速度。


## 如何計算 P99?
### 1. Raw Data / Naive Approach
把所有收到的請求延遲數據，一筆一筆原封不動地存進一個大陣列（List/Array）中。

* **實作方式：**
    * 資料結構：`List<Long> latencies`
    * 計算 P99：先對整個 List 進行**排序 (Sort)**，然後直接取第 99% 位置的數值。
* **優點：**
    * **絕對精準：** 這是真理，沒有任何誤差，你是 100μs 就是 100μs。
* **缺點：**
    * **記憶體爆炸 (Memory O(N))：** 請求越多，記憶體吃越兇。跑一整天可能有幾億筆資料，記憶體直接溢位 (OOM)。
    * **運算極慢：** 每次算 P99 都要排序 (Sorting)，時間複雜度是 $O(N \log N)$。在高頻系統中這是不允許的。
    * **無法合併：** 如果你有 10 台機器，很難把這 10 堆亂七八糟的原始數據合併算出一個總的 P99。


### 2. Standard / Linear Histogram
放棄紀錄「每一筆」資料，改用「固定大小的桶子 (Fixed-size Buckets)」來統計次數。
* **實作方式：**
    * 就像一把普通的尺，刻度是固定的（例如每 1ms 一格）。
    * `Bucket[0]` 存 0~1ms, `Bucket[1]` 存 1~2ms...
* **優點：**
    * **寫入極快：** 算出 Index 後直接 `Count++`，時間複雜度 $O(1)$。
    * **資料量小於 Raw Data：** 不管請求有幾億筆，只要桶子數量固定，記憶體就不會無限增長。
* **缺點：**
    * **無法兼顧「廣度」與「精度」：**
        * **如果要精準 (桶子設 1μs)：** 為了測量到 1 分鐘 (60秒)，你需要宣告 **6000 萬個桶子**的陣列。記憶體浪費巨大（大部分桶子是空的）。
        * **如果要省記憶體 (桶子設 100ms)：** 1ms 的請求和 99ms 的請求會掉進同一個桶子，你完全看不出系統優化的效果，**精度太差**。



### 3. HdrHistogram (High Dynamic Range Histogram)
針對「高動態範圍」設計的直方圖。使用 **有效位數 (Significant Figures)** 的概念，讓桶子的寬度隨著數值變大而指數級變寬。

* **實作方式：**
    * **動態刻度 (Logarithmic Buckets)：**
        * 在 1~100μs 範圍：桶寬可能只有 1μs（超精細）。
        * 在 100ms~200ms 範圍：桶寬可能變成 100μs。
        * 在 10s~20s 範圍：桶寬可能變成 10ms。
    * **保證相對誤差：** 確保任何數值的誤差都控制在固定百分比內（例如 < 1%）。
* **優點 (最佳解)：**
    * **極省記憶體：** 通常只需要 **幾 KB 到幾百 KB** 的固定大小記憶體，就能精確覆蓋從 1μs 到 24 小時的範圍。
    * **同時捕捉微觀與宏觀：** 既能分辨 10μs 與 11μs 的差異，也能紀錄 10 秒的大延遲，不需要取捨。
    * **Zero Allocation：** 適合高頻交易，運作時不會頻繁配置記憶體，不會觸發 GC。
* **缺點：**
    * **大數值的絕對誤差較大：** 對於 60 秒的延遲，它可能會有 0.5 秒的誤差（但在統計上，分辨 60.0s 和 60.5s 通常沒意義）。


### 總結比較表
| 特性 | **1. Raw Data** | **2. Linear Histogram** | **3. HdrHistogram** |
| :--- | :--- | :--- | :--- |
| **核心邏輯** | 全記錄 (List) | 固定寬度桶子 (Fixed Bucket) | 指數寬度桶子 (Log Bucket) |
| **記憶體消耗** | **極高** (隨資料量無限增長) | **高** (若要高精度+大範圍) | **極低** (固定，例如 16KB) |
| **精確度** | 100% 完美 | 取決於桶寬，通常有折衷 | **相對精度恆定** (如 99.9%) |
| **運算速度** | **慢** (需排序) | 快 (O(1)) | 快 (O(1)) |
| **測量範圍** | 無限制 | 受限於陣列大小 | **極大** (微秒至數天) |
| **適用場景** | 開發測試、資料量極少時 | 數值範圍很窄時 (如考試成績) | **高頻交易、系統效能監控** |

