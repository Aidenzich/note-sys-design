# 系統設計速成指南：交付框架 (Delivery Framework)

這是一套由 FAANG 經理和主任工程師（Staff Engineers）建立的方法，旨在幫助你在系統設計面試中組織思維，並專注於最重要的面向。

在系統設計面試中，搞砸錄取機會最簡單的方法就是**未能交付一個可運作的系統**。這是中階候選人面試失敗最常見的原因，且通常被模糊地歸類為「時間管理」問題。問題的核心並不（總是）在於你需要做得快兩倍——很多時候，你只是需要專注在對的事情上。

## 整體結構

我們的「交付框架」是一套建議你在面試中採用的步驟順序與時間分配。透過這種方式組織面試，你可以專注於面試官最重視的部分。另一個好處是，如果你感到不知所措，這是一條清晰的退路。許多候選人在面試中感到緊張（這很正常！），如果沒有依循線性的方式構建解決方案，很容易迷失方向。

雖然擁有穩固的結構很重要，且面試官並未受過專門訓練來評估你的「交付方式」（這通常被歸類為「溝通能力」），但實務上我們看到，遵循結構的候選人表現顯著較好，這既能防止他們卡住，又能確保他們交付出一個可運作的系統。

以下是框架內容！

![alt text](<imgs/Screenshot 2025-12-25 at 8.17.31 PM.png>)

## 建議的系統設計面試結構

### 1. 需求分析 Requirements (~5 分鐘)

需求分析階段的目標是清楚理解你被要求設計的系統。為此，我們建議將需求分為兩部分。

#### 1) 功能性需求 (Functional Requirements)

功能性需求是那些「使用者/客戶端應該能夠...」的陳述。這是系統的核心功能，也是你應該與面試官首先討論的內容。這通常是一個與面試官來回溝通的過程。你要像在跟客戶、消費者或產品經理對話一樣，提出針對性的問題（例如：「系統需要做 X 嗎？」「如果發生 Y 會怎樣？」），以得出核心功能的優先順序列表。

例如，如果你要設計像 Twitter 這樣的系統，你可能會有以下功能性需求：

* 使用者應該能夠發布推文 (post tweets)
* 使用者應該能夠追蹤其他使用者 (follow users)
* 使用者應該能夠看到他們追蹤的使用者的推文 (feed)

如果是設計快取 (Cache) 系統，需求可能像這樣：

* 客戶端應該能夠插入項目
* 客戶端應該能夠設定過期時間
* 客戶端應該能夠讀取項目

**保持需求具針對性！** 面試剩餘時間的主要目標是開發一個滿足你所定義需求的系統——因此，策略性地排列優先順序至關重要。許多系統有數百項功能，但你的工作是識別並優先處理**前 3 項**。列出一長串需求對你的傷害大於幫助，許多頂尖 FAANG 公司會直接評估你「專注於重要事項」的能力。

#### 2) 非功能性需求 (Non-functional Requirements)

非功能性需求是關於對使用者很重要的「系統品質」陳述。這些可以用「系統應該能夠...」或「系統應該是...」來表達。

以 Twitter 為例，非功能性需求可能包括：

* 系統應具備高可用性 (Highly Available)，且可用性優於一致性 (Availability over Consistency)。
* 系統應能擴展以支援 1億+ DAU（日活躍用戶）。
* 系統應具備低延遲，需在 200ms 內呈現動態消息 (feed)。

重要的是，非功能性需求應置於系統的情境中，並盡可能**量化**。例如，「系統應該低延遲」是很明顯且不太有意義的——幾乎所有系統都應該低延遲。「系統的搜尋功能應具備低延遲，小於 500ms」則有用得多，因為它指出了最需要低延遲的部分並設定了目標。

提出非功能性需求可能具有挑戰性，特別是當你不熟悉該領域時。以下是一份檢查清單，可幫助你識別系統中最重要的非功能性需求（請選出與你的系統最相關的前 3-5 項）：

* **CAP 定理：** 你的系統應該優先考慮一致性 (Consistency) 還是可用性 (Availability)？注意，在分散式系統中，分區容錯性 (Partition Tolerance) 是既定條件。
* **環境限制：** 系統運行的環境有任何限制嗎？例如，是在電池壽命有限的行動裝置上運行？還是在記憶體或頻寬有限的裝置上（如在 3G 網絡上串流影片）？
* **可擴展性 (Scalability)：** 所有系統都需要擴展，但此系統是否有獨特的擴展需求？例如，是否在一天中的特定時間有突發流量？是否有特定事件（如節日）會導致流量顯著增加？這裡也要考慮讀寫比 (Read vs Write ratio)。你的系統更需要擴展讀取還是寫入？
* **延遲 (Latency)：** 系統需要多快回應使用者請求？特別考慮那些需要實際運算的請求。例如，設計 Yelp 時的低延遲搜尋。
* **持久性 (Durability)：** 系統中的資料不丟失有多重要？例如，社群網路可能可以容忍少量資料遺失，但銀行系統則不行。
* **安全性 (Security)：** 系統需要多安全？考慮資料保護、存取控制和法規遵循。
* **容錯性 (Fault Tolerance)：** 系統處理故障的能力如何？考慮冗餘、故障轉移 (Failover) 和復原機制。
* **合規性 (Compliance)：** 是否有法律或監管要求？考慮行業標準、資料保護法和其他法規。

### 3) 容量估算 Capacity Estimation (視情況而定)

許多指南建議在這個階段進行「粗略估算」(back-of-the-envelope calculations)。我們認為這通常是**不必要的**。建議只有在計算結果會**直接影響你的設計**時才進行計算。在大多數情況下，你面對的是一個大型分散式系統——這是一個合理的預設。許多候選人計算儲存量、DAU 和 QPS，最後只得出結論：「好的，量很大。懂了。」作為面試官，除了知道你會基本的算術外，我們從中得不到任何資訊。

我們的建議是告訴面試官，你希望跳過事前的估算，並會在設計過程中**必要時**才進行數學計算。什麼時候是必要的？想像你在設計 Facebook 貼文的熱門話題 TopK 系統。你會想估算預期的話題數量，因為這會影響你是可以使用單一實例的資料結構（如 Min-Heap），還是需要將其分片 (Shard) 到多個實例中，這對設計有重大影響。

無論你最終如何在面試中使用它，學會快速估算相關數量將有助於你在設計中快速推理權衡 (Trade-offs)。如果你在壓力下不擅長心算也不用擔心，大多數人都不擅長。

### 2. 核心實體 Core Entities (~2 分鐘)

接下來，你應該花點時間識別並列出系統的 **核心實體** 或是 **大名詞**。這樣做是為了先跟面試官對齊術語，讓彼此知道這是在聊什麼，也為後續的設計打底。

說白了，這些實體就是你資料庫裡會有的資料表，也是 API 丟來丟去的資料物件。在面試時不用想得太複雜，直接列出幾個重點項目，跟面試官說：『這是我初步想到的幾個主要實體』就可以了。

為什麼不在這時列出完整的資料模型？因為**你不知道你不知道什麼**。隨著系統設計的進行，你會發現先前未預料到的新實體和關係。從一個小清單開始，你可以快速迭代並隨時添加。一旦進入高階設計，並且更清楚每個請求需要更新什麼狀態時，你就可以開始為每個實體建立相關的欄位清單。

以 Twitter 為例，我們的核心實體相當簡單：

* User (使用者)
* Tweet (推文)
* Follow (追蹤關係)

幾個有助於識別核心實體的問題：

* 系統中的參與者是誰？他們有重疊嗎？
* 滿足功能性需求所必需的名詞或資源是什麼？

> 盡量為你的實體選擇好的名稱。有些面試官會利用這個機會觀察你是否擅長電腦科學中最困難的問題之一（命名）。


### 3. API 或系統介面 System Interface (~5 分鐘)
在進入高階設計之前，你要定義系統與使用者之間的契約 (Contract)。通常，特別是在全產品類型的面試中，這直接對應到你已經識別的功能性需求（但不總是！）。你將使用此契約來指導高階設計，並確保你滿足了已識別的需求。

這裡你需要做一個快速決定——使用哪種 API 協定？
* **REST:** 使用 HTTP 動詞 (GET, POST, PUT, DELETE) 對資源執行 CRUD 操作。這應該是大多數面試的**預設選擇**。
* **GraphQL:** 允許客戶端精確指定他們想要接收的資料，避免過度獲取 (over-fetching) 或獲取不足 (under-fetching)。當你有具有不同資料需求的多樣化客戶端時，選擇此項。
* **RPC (遠端程序呼叫):** 面向動作的協定（如 gRPC），在服務對服務 (Service-to-Service) 通訊中比 REST 更快。當效能至關重要時，用於內部 API。

**不要想太多。除非有特定理由，否則預設使用 REST。** 對於即時功能，你可能還需要 `WebSocket` 或 `Server-Sent Events`，但請先設計核心 API。

對於 Twitter，我們會選擇 REST 並使用我們的核心實體作為資源來設計端點。資源應該是代表系統中事物的複數名詞：
```text
POST /v1/tweets
body: { "text": string }

GET /v1/tweets/{tweetId} -> Tweet

POST /v1/follows
body: { "followee_id": string }

GET /v1/feed -> Tweet[]

```

> 注意我們使用複數資源名稱（tweets，而不是 tweet）。使用**複數名詞（Plural Nouns）**是一個業界標準的慣例。

> **注意：** 永遠不要依賴請求本體中的敏感資訊（如 User ID），這些應該來自身份驗證。始終驗證請求並從 Auth Token 推導當前使用者，而不是從使用者輸入中獲取。

### 4. [可選] 資料流 Data Flow (~5 分鐘)

對於某些後端系統，特別是資料處理系統，描述系統對輸入執行的一系列高階動作或流程以產生預期輸出會很有幫助。如果你的系統不涉及長串的動作序列，**請跳過此部分！**

我們通常透過簡單的列表來定義資料流。你將使用此流程來告知下一節的高階設計。
對於網路爬蟲 (Web Crawler)，這可能看起來像：

1. 獲取種子 URLs
2. 解析 HTML
3. 提取 URLs
4. 儲存資料
5. 重複

---

### 5. 高階設計 High Level Design (~10-15 分鐘)



現在你對系統的需求、實體和 API 有了清晰的理解，可以開始設計高階架構了。這包括畫出代表系統不同組件的方塊和箭頭，以及它們如何互動。組件是基本的構建模組，如伺服器、資料庫、快取等。這可以在白板上完成，也可以使用像 Excalidraw 這樣的虛擬白板軟體。

> **提示：** 詢問你的招募人員面試將使用什麼軟體，並提前練習。你不會希望在面試中手忙腳亂地操作軟體。

**不要想太複雜！** 你的主要目標是設計一個滿足你設計的 API（進而滿足需求）的架構。在大多數情況下，你甚至可以逐一檢查你的 API 端點，並按順序構建設計以滿足每一個端點。

**保持專注！** 候選人常常過早疊加複雜度，導致永遠無法得出完整的解決方案。**專注於一個相對簡單、能滿足核心功能性需求的設計**，然後在「深入探討」階段再疊加複雜度以滿足非功能性需求。在高階設計階段識別出可以增加複雜度的地方（如 Cache 或 Message Queue）是很自然的，我們鼓勵你口頭提出並做個簡單的筆記，然後繼續前進。

在你繪製設計時，你應該向面試官口述你的思考過程。明確說明資料如何流經系統，以及每個請求會改變什麼狀態（在Database、Cache、Message Queue等），從 API 請求開始直到回應結束。當請求到達資料庫或持久層時，是開始記錄每個實體相關欄位的好時機。你可以直接在視覺化的資料庫旁邊做這件事。這有助於將資訊保留在相關組件附近，並隨著設計迭代而容易修改。不必太擔心型別，面試官可以推斷，寫出來只會拖慢你的速度。

> **注意：** 不要浪費時間記錄 Schema 中的每個欄位。例如，面試官知道 User 表有名稱、Email 和密碼雜湊，所以你不需要寫下來。相反，專注於與設計特別相關的欄位。

對於 Twitter 範例，你可以一次一個端點地構建設計。
![alt text](<imgs/Screenshot 2025-12-25 at 8.18.19 PM.png>)



### 6. 深入探討 Deep Dives (~10 分鐘)
敏銳的讀者可能已經注意到，上面的 Twitter 高階設計在獲取使用者動態消息 (Feed) 時效率會低得可憐。沒問題！這正是你在深入探討部分要迭代改進的。現在你有了一個高階設計，你要利用剩下的 10 分鐘左右來**強化你的設計**，透過：
(a) 確保它滿足所有非功能性需求
(b) 解決邊緣情況 (Edge Cases)
(c) 識別並解決問題和瓶頸
(d) 根據面試官的探問改進設計

你在引導深入探討時的主動程度取決於你的資歷。較資淺的候選人可以預期面試官會介入並指出設計可以改進的地方。較資深的候選人應該能夠自己識別這些地方並引導討論。

例如，我們對 Twitter 的非功能性需求之一是系統需擴展至 >100M DAU。我們可以引導一場關於水平擴展、引入快取和資料庫分片 (Sharding) 的討論——邊討論邊更新設計。另一個需求是 Feed 需要低延遲獲取。在 Twitter 的案例中，這實際上是最有趣的問題。我們會引導討論關於「讀取時擴散」(Fanout-on-read) 與「寫入時擴散」(Fanout-on-write) 以及快取的使用。

**候選人常犯的一個錯誤是試圖蓋過面試官的聲音。** 確實有很多可以談論的內容，對於資深候選人來說，主動很重要，但這需要平衡。確保你留給面試官提問和探測你設計的空間。他們很可能有特定的訊號想要從你身上獲取，如果你忙著一直講話，就會錯過這些訊號。此外，這也會損害你在溝通與協作方面的評價。